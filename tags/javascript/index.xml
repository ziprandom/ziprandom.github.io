<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on random comments</title>
    <link>https://ziprandom.github.io/tags/javascript/</link>
    <description>Recent content in Javascript on random comments</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 23 Sep 2016 16:00:00 -0300</lastBuildDate>
    <atom:link href="https://ziprandom.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>2016 - Personal Choice for WebApp Development</title>
      <link>https://ziprandom.github.io/blog/2016_js_development_choice/</link>
      <pubDate>Fri, 23 Sep 2016 16:00:00 -0300</pubDate>
      
      <guid>https://ziprandom.github.io/blog/2016_js_development_choice/</guid>
      <description>

&lt;p&gt;Just a snapshot of what I use for effective &amp;amp; fun JS Webdevelopment right now.&lt;/p&gt;

&lt;p&gt;Js Webapp development has become really fun for me since I discovered &lt;a href=&#34;https://facebook.github.io/react/&#34;&gt;React&lt;/a&gt;. What I do ever since is build UI centric Applications around a preferably immutable state. I tried &lt;a href=&#34;http://redux.js.org/&#34;&gt;Redux&lt;/a&gt; but found it to be overhead for the small applications I developed. So I mostly stick with &lt;a href=&#34;https://github.com/Yomguithereal/baobab&#34;&gt;Baobab&lt;/a&gt; that I serve as a &lt;a href=&#34;https://github.com/Reactive-Extensions/RxJS&#34;&gt;RxJS&lt;/a&gt; &lt;a href=&#34;https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/creating.md&#34;&gt;Observable Sequence&lt;/a&gt;, a Stream that floats through the Application from (abstraction) top to bottom.&lt;/p&gt;

&lt;h3 id=&#34;ui-templating-react-stateless-functional-components&#34;&gt;UI / Templating: React (Stateless) Functional Components&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Template Component&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const PostsTemplate = ({posts, page, setPage}) =&amp;gt; (
  &amp;lt;div&amp;gt;
    /* Navigation */
    {posts.map(
      (_, index) =&amp;gt; (
        &amp;lt;a onClick={() =&amp;gt; setPage(index)}&amp;gt;
          {index}
        &amp;lt;/a&amp;gt;
      )
    )}
    /* Posts Carousel */
    &amp;lt;Slider&amp;gt;
    {posts.map(
      (post, index) =&amp;gt; (
        &amp;lt;Slide className={index == page ? &#39;active&#39; : &#39;hidden&#39;}&amp;gt;
          &amp;lt;PostTemplate post={post} /&amp;gt;
        &amp;lt;/Slide&amp;gt;
      )
    )}
    &amp;lt;/Slider&amp;gt;
  &amp;lt;/div&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Higher Order Component to Decorate Template with State Stream derived Data&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const OnPostsFromStateRefresh = recompose.compose(
  recompose.mapPropsStream(
    () =&amp;gt; stateStream.distinctUntilChanged(
      /* wait until (posts or page) change
         ignore rest of the states updates */
      (state) =&amp;gt; [
          state.get(&#39;posts&#39;), state.get(&#39;page&#39;)
      ]
    )
  ),
  /* extract what we need to render the
     PostsTemplate */
  recompose.mapProps(
    (state) =&amp;gt; ({
      posts: state.get(&#39;posts&#39;),
      page: state.get(&#39;page&#39;),
      /* here we take a cursor
         and pass its set function */
      setPage: state.select(&#39;page&#39;).set
    })
  )
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Combine Template and Higher Order Component&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = OnPostsFromStateRefresh(PostsTemplate);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I create hierarchical React components to layout the UI. React can express all of the UI&amp;rsquo;s logic and depends on the state for the data to display. The state or relevant-sections of it as &lt;a href=&#34;https://github.com/Yomguithereal/baobab#cursors&#34;&gt;cursors&lt;/a&gt; get passed down the component hierarchy from the abstract &lt;code&gt;&amp;lt;App&amp;gt;...&amp;lt;/App&lt;/code&gt; component down to the &lt;code&gt;&amp;lt;button onClick={..}&amp;gt;...&amp;lt;/button&amp;gt;&lt;/code&gt; that directly renders to the button dom element. I don&amp;rsquo;t use ES6 Classes to express components, but define components as Pure Functions that take properties (including state) and return Virtual Dom Nodes. By Nesting Pure Functional Components in HoC a separation of logic is achieved in a functional way, not unlike Rails` middleware onion. I make excessive use of the Higher Order Components provided by the &lt;a href=&#34;https://github.com/acdlite/recompose/blob/master/docs/API.md&#34;&gt;React utility belt Recompose&lt;/a&gt; that also help in coupling Dom to the states Observable Stream.&lt;/p&gt;

&lt;h3 id=&#34;processing-building-bundling&#34;&gt;Processing / Building / Bundling&lt;/h3&gt;

&lt;p&gt;The by far handiest js build system and dev server I&amp;rsquo;ve encoutered is &lt;a href=&#34;https://webpack.github.io/&#34;&gt;Webpack&lt;/a&gt;. I use it with the &lt;a href=&#34;https://babeljs.io/docs/setup/#installation&#34;&gt;Babel&lt;/a&gt; transpiler to polyfill ES6 Syntax (&lt;code&gt;({a, b}) =&amp;gt; ({a,...b})&lt;/code&gt;) with Reacts JSX &lt;code&gt;&amp;lt;MyFunkyComponent/&amp;gt;&lt;/code&gt; as well as preprocess and deliver (s)css, fonts and assets bundled inside that same minified js file. Basically everything is available through the &lt;code&gt;import&lt;/code&gt; (&lt;code&gt;@import&lt;/code&gt; for styles) or &lt;code&gt;require&lt;/code&gt; syntax. I love it so much! &lt;a href=&#34;https://www.npmjs.com/&#34;&gt;Node Package Manager&lt;/a&gt; is used to install everything I need. And &lt;a href=&#34;https://www.docker.com/&#34;&gt;docker&lt;/a&gt; Hosts the whole js dev environment.&lt;/p&gt;

&lt;h3 id=&#34;immutable-global-state&#34;&gt;Immutable Global State&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import BaoBab form &#39;baobab&#39;;
import recompose from &#39;recompose&#39;;

// the initial State
let state = new BaoBab({
    posts: [],
    page: 0
});

// couple the BaoBab event based updateCallback
// with an Observable Stream
let handler = recompose.createEventHandler(state);
state.on(&#39;update&#39;,
  event =&amp;gt; handler.handler(event.target)
)

// create a higher order component
// to wrap react components with
// stateStream updates
let onStateStream = recompose.mapPropsStream(
  props$ =&amp;gt; handler.stream.startWith(state)
);

module.exports(onStateStream)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The state basically is &lt;strong&gt;one big immutable Hash that gets passed to the Component (Render) Functions whenever it updates&lt;/strong&gt;. The keys that didn&amp;rsquo;t change still have the same id. So for an unchanged key &lt;code&gt;a&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;oldState.get(&#39;a&#39;)
  === newState.get(&#39;a&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;holds and components that are guarded by the &lt;code&gt;recompose.pure()&lt;/code&gt; Higher Order Component don&amp;rsquo;t do unnecessary updates. If the value of a part of the tree change you are garanteed to get a new Object &lt;code&gt;!==&lt;/code&gt; the old State&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;postsCursor =
  state.select(&#39;posts&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;returns a cursor that can be used to retrieve the value &lt;code&gt;postsCursor.get()&lt;/code&gt; as well as trigger a state update &lt;code&gt;postsCursor.set([])&lt;/code&gt;. Parts of the State can also be subscribed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javasrcript&#34;&gt;postsCursor.on(
  &#39;update&#39;,
  (posts) =&amp;gt; ...
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ide-editing&#34;&gt;IDE / Editing&lt;/h3&gt;

&lt;p&gt;Emacs, what else :D &lt;a href=&#34;http://web-mode.org/&#34;&gt;web-mode&lt;/a&gt; does a nice job highlighting and aligning es6 syntax and various template languages like JSX. Also did I find &lt;a href=&#34;https://magit.vc/&#34;&gt;magit&lt;/a&gt; to be the best way to use git.&lt;/p&gt;

&lt;h3 id=&#34;libs-services&#34;&gt;Libs/Services&lt;/h3&gt;

&lt;p&gt;The Ajax Library of choice is &lt;a href=&#34;http://visionmedia.github.io/superagent/&#34;&gt;superagent&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;testing&#34;&gt;Testing&lt;/h3&gt;

&lt;p&gt;I use &lt;a href=&#34;https://chimp.readme.io/&#34;&gt;chimp&lt;/a&gt; to run end-to-end tests defined in &lt;a href=&#34;https://chimp.readme.io/docs/getting-started&#34;&gt;cucumber scenarios&lt;/a&gt;. The nice separation of concerns let&amp;rsquo;s us easily test the dom independent parts like state and services with &lt;a href=&#34;http://jasmine.github.io/&#34;&gt;yasmine unit tests&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For single page apps I like to write &lt;code&gt;DomInteraction-to-ApiCall&lt;/code&gt; &amp;amp; &lt;code&gt;ApiResults-to-DomLayout&lt;/code&gt; e2e-tests. Therefore I created a set of cucumber steps to define backend API mocks and ajax expectation inline in the gherkin file. From &lt;a href=&#34;https://github.com/ziprandom/cucumberjs-json-api-mocking&#34;&gt;github/cucumberjs-json-api-mocking&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gherkin&#34;&gt;# The XMLHttpRequest and Response Mocks are
# injected into the browser context. Every
# call now gets intercepted,logged and answered
# if a proper response is defined.
And I start mocking &amp;quot;http://localhost:8000&amp;quot;

# An API request is triggered via the ui
When I input &amp;quot;My fancy new Todo&amp;quot; into the Todo Input
And I press Return

# Expected API behavior can be defined after the request
Then a &amp;quot;post&amp;quot; to &amp;quot;/api/todos&amp;quot; should have happened with:
&amp;quot;&amp;quot;&amp;quot;
  {
    &amp;quot;title&amp;quot;: &amp;quot;My fancy new Todo&amp;quot;,
    &amp;quot;completed&amp;quot;: false
  }
&amp;quot;&amp;quot;&amp;quot;

# API mocks can also be defined after the request was made
# a loop waits 5 secs before a timeout is triggered.
Given the API responds to the &amp;quot;post&amp;quot; on &amp;quot;/api/todos&amp;quot; with &amp;quot;201&amp;quot;:
&amp;quot;&amp;quot;&amp;quot;
  {
    &amp;quot;id&amp;quot;: 5701886678138880,
    &amp;quot;title&amp;quot;: &amp;quot;My fancy new Todo&amp;quot;,
    &amp;quot;completed&amp;quot;: false
  }
&amp;quot;&amp;quot;&amp;quot;

# When we made sure, the app makes the right api calls
# and provide it with backend feedback we can go on
# testing the ui.
Then an active Todo &amp;quot;My fancy new Todo&amp;quot; should be visible
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>